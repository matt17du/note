

### 单例



优点：避免频繁创建对象带来的资源消耗

缺点：单例模式一般是没有接口，扩展性较差





### 观察者模式







### 代理模式

职责更加清晰，可以把业务代码无关的代码交给代理对象去执行，我们只需要关注业务代码即可。

#### 普通代理

对用户来说是透明的并不知道真实对象的存在



```java
interface Subject {
      void play();
}

class RealSubject implements Subject {
    
   private String name;
    
    public RealSubject(String name){
            this.name = name;
    }
    
    public void play(){
        
    }
}

class Proxy implements Subject {
    
    private String name;
    private Subject obj;
    public Proxy(String name) {
        obj = new RealSubject(name);
    }
    
     public void play(){
        obj.play();
    }
    
}
```

#### 强制代理

不能自己创建代理对象，需要真实对象指定代理对象。

```java
interface Subject {
      void play();
}

class RealSubject implements Subject {
    
   private String name;
   private Subject proxy;
    
    public RealSubject(String name){
            this.name = name;
    }
    
    public Subject getProxySubject() {
        this.proxy = new Proxy(this);
    }
    
    public void play(){
        
    }
}

class Proxy implements Subject {
    
    private String name;
    private Subject obj;
    public Proxy(Subject obj) {
        this.obj = obj;
    }
    
     public void play(){
        obj.play();
    }
    
}
```





### 工厂方法模式

用户不需要关心他是如何创建，抽象类的耦合，耦合类低，扩展性高





### 抽象工厂

A类产品：A1,A2

B类产品：B1,B2



A1 B1 ：一个产品线

工厂1：A1, B1  



工厂2：A2, B2







### 策略模式

定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。

```java
/**
 * 实现容易，但是代码变多之后，难于维护。
 * 如果有增长类型，就需要频繁修改此处的代码！
 * 不符合开闭原则
 *
 */
public class nostrategy {
    public double getPrice(String type, double price){
        if(type.equals("普通客户小批量"))
        {
            System.out.println("不打折");
            return price;
        }
        else if(type.equals("普通客户大批量")){
            System.out.println("打九折");
            return price*0.9;
        }else if(type.equals("老客户小批量")){
            System.out.println("打八五折");
            return price*0.85;
        }else if(type.equals("老客户大批量")){
            System.out.println("打八折");
            return price*0.8;
        }
        return price;
    }
}

```





```java
public class Client {
    public static void main(String[] args) {
        Strategy s1 = new OldCustomerManyStrategy();
        Context ctx  = new Context(s1);
        ctx.printPrice(998);
    }

}
```

#### 优点

避免使用多重条件转移语句，如if...else...语句、switch 语句

扩展性较好

#### 缺点

策略类数量增多
每一个策略都是一个类，复用的可能性很小，类数量增多。
所有的策略类都需要对外暴露